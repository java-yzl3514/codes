APIE ?

Polymorphism

  Polimorfizm, kelime kökeni olarak Yunanca "çok" anlamına genel poly ve "biçim" anlamına gelen morphe kelimelerinden
  türetilmiştir. OOP bağlamında polimorfizm, bir referansın veya arayüzün, farklı altta yatan nesne türlerine aitmiş
  gibi davranabilmesi yeteneğidir. Daha basit bir ifadeyle, aynı mesajın (metot çağrısının) farklı nesneler
  tarafından farklı şekilde yorumlanması ve uygulanmasıdır.
    OOP'nin temel amacı, gerçek dünyadaki varlıkları ve onların etkileşimlerini modellemektir. Polimorfizm, bu modellemede
    esneklik ve genişletilebilirlik sağlar. Örneğin, bir "Hayvan" referansımız olduğunda, bu referansın bir "Kedi" nesnesini mi
    yoksa bir "Köpek" nesnesini mi tuttuğunu bilmeden sesCikar() metodunu çağırabiliriz. Çağrı yapıldığında, Java Sanal
    Makinesi doğru nesnenin metodunu çalıştırır.Bu programın akışını nesnelerin somut (concrete) tiplerden ayırarak
    daha soyut (abstract) ve yönetilebilir hale getirir.
     ! --- Bu örnekten yola çıkarak, önceki dersimizde kurduğumuz GeometricObject ve ilgili alt sınıflar için nasıl
     uygulayacağımızı düşünelim.

Java'da polimorfizm temelde iki kategoriye ayrılır:

 1. Statik(Derleme Zamanı) Polimorfizm: Metot Aşırı Yükleme (Method Overloading / Early Binding)
   Bunu ilgili derste konuşmuştuk.

 2. Dinamic(Çalışma Zamanı) Polimorfizm: Method Overriding
   Bu, OOP'de polimorfizmin en saf ve en güçlü halidir. Hangi metodun çağrılacağına çalışma zamanında(run-time) karar
   verilir. Bu mekanizma kalıtım üzerine kuruludur.

 Gereklilikleri :
   1. Kalıtım (IS-A İlişkisi): Bir alt sınıf (subclass), bir üst sınıfı(superclass) extends anahtar kelimesiyle
   genişletmelidir.
   2. Method Overriding: Alt sınıf, üst sınıftaki bir metodu aynı isim, aynı parametreler ve aynı dönüş tipi (veya
   alt tipi, JAVA 5 : Covariant Return Type) ile yeniden tanımlamalıdır.(Uygun access modifier olması, final veya static
     olmaması koşuluyla)
     @Override anotasyonu bu işlemi güvenli hale getirmek için kullanılır.

Upcasting Hatırlatması:
   Çalışma zamanında, üst sınıf türünden bir referans, bir alt sınıf nesnesini gösterebilir.Bu referans üzerinden bir
   çağrımı yapıldığında, JVM referansın türüne değil, bellekteki nesnesinin gerçek türüne bakarak hangi metodu çalıştıracağına
   karar verir. Bu işleme "geç bağlama" (late-binding) veya Dinamik Metot Dağıtımı (Dynamik Method Dispatch) denir.


Hatırlayalım :
Aşağıdaki tasarım S.O.L.I.D. ilkelerinden O ilkesinin ihlaline sebep verebilir.
bknz: https://en.wikipedia.org/wiki/SOLID

GeometricObject sınıfının arayüzüne(interface) print metodu/yeteneği eklendi.
Ve buna bağlı olarak GeometricObjects sınıfının değişmine dikkat edelim.

 package com.ba.yzl3514.domain.geometric;

 import java.awt.*;

 /**
  *
  *
  *
  * @author Onder Sahin
  *
  */
 public class GeometricObject {

     private Color color;


     public void print(){
         System.out.println("--- Geometric object info not found ---");
     }

 }
.....
 /**
  *
  *
  *
  * @author Onder Sahin
  *
  */
 public class GeometricObjects {


     public static void print(GeometricObject geometricObject){

         if(geometricObject instanceof Rectangle rectangle){
             rectangle.print();
         }else if(geometricObject instanceof Square square){
             square.print();
         }else if(geometricObject instanceof Circle circle){
             circle.print();
         }
     }

 }

...
 package com.ba.yzl3514.domain.geometric;

 /**
  *
  *
  *
  * @author Onder Sahin
  *
  */
 public class GeometricObjects {


     public static void print(GeometricObject geometricObject){
         geometricObject.print();
     }

 }

 Gözlem: Geometric sınıfların birinden print metodunu kaldırarak Driver sınıfını yeniden çalıştırın ve
 gözlemleyin.

 JLS, Overriding (by Instance Methods)
  Bu bölümde  bir  metodun ne zaman diğerinin davranışını değiştirdiği (override ettiği) tanımlanır.

Çalışma zamanı polimorfizmin arkasındaki anahtar mekanizma Dinamik Metot Dağıtımıdır.JVM nesneleri bellekte oluşturduğunda,
her sınıf için bir Sanal Metot Tablosu (Virtual Method Table- VTable) tutar.Bu tablo, metot imzalarını o sınıf için çalıştırılacak
olan gerçek metot implementasyonlarının bellek adresleriyle eşleştirilir.Bir alt sınıf, bir metodu override ettiğinde,
kendi VTable'ındaki ilgili metot girişini kendi implementasyonunun adresiyle günceller.

Overriding Teknik Kuralları

1. Metot İmzası(Method Signature) : Metot adı ve parametre listesi(tür, sayı ve sıra) üst sınıftaki metot ile
birebir aynı olmalıdır.
2. Erişim Berlirleyicisi(Access Modifier): Override edilen metot, üst sınıftaki metottan daha kısıtlayıcı
bir erişim seviyesine sahip olamaz. Örneğin protected bir metot private olarak override edilemez.
Bunun tersi uygundur. Yani protected bir metot public olarak override edilebilir.

3.Dönüş Tipi(Return Type): Java 5'ten önce dönüş tipi de birebir aynı olmak zorundaydı. Java 5 (Tiger) ile birlikte
Kovaryant Dönüş Tipleri (Covariant Return Type) özelliği geldi. Bu, override eden metodun dönüş tipinin, üst sınıftaki
metodun dönüş tipinin bir alt sınıfı olabileceği anlamına gelir. Bu, cast ihtiyacını ortadan kaldıran bir özelliktir.

4.Exceptions: Override edilen metot, üst sınıftaki metodun throws anahtar sözcüğü ile bildirdiği
kontrol edilen istisnalardan (cheched exceptions) daha genel veya yeni bir istisna fırlatamaz.
Daha dar kapsamlı bir istisna türü fırlatabilir veya hiç fırlatmayabilir.

IOException : https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html

------------------------------------------------------------------------------------
@Override Annotasyonu
 Bu anotasyon, override işlemini sağlamaz !
 Bu anotasyon yukarıda belirttiğimiz kuralların derleyici tarafından esktra kontrol edilmesini
 sağlar ve olası hataları önler( Örn: metot adını yanlış yazmak)
 Bu anotasyon olmasa da overriding kuralları nettir ve uygulanır.
 Bu anotasyon aynı zaman kaynak kod üzerinde ekstra bilgi sağlar. Bu da okunaklılık üzerinde
 büyük bir etkiye sahiptir. Yani geliştirici bir sınıf içerisinde hangi metotların üst sınıftan
 override edildiği daha net algılar.
 Biz de derslerimizde bu anotasyonunun kullanımına dikkat edeceğiz. Profesyonel projelerde de
 buna dikkat edilmesi önerilir.
 ---------------------------------------------------------------------------------------

  private metotlar override edilemez
  final olarak işaretlenmiş metotlar override edilemez
  static metotlar sınıfa aittir, nesneye değil. Bu nedenle override edilemezler.

 !! static metotlar final olarak işaretlenebilir. Bu durumda alt sınıfta aynı isimde metot
 tanımlanması önlenmiş olur.Bu çok tercih edilen bir yazım şekli değildir.

 !! üst sınıfta tanımlanan static metodun erişim belirleyicisi seviyesi alt sınıfta
 aynı imza ile bildirilmiş statik metot için daha kısıtlayıcı bir seviyede olamaz

 public class A {

     private void foo(){

     }

     public final void bar(){

     }

     public static void staticMethod(){
         System.out.println("A.staticMethod");
     }
 }

 public class B extends A{

     public void foo() {

     }

     /*
     CAN NOT OVERRIDE
     @Override
     public void bar(){

     }
      */

     private static void staticMethod(){ // CAN NOT WRITE private
         System.out.println("B.staticMethod");
     }
 }

 public class Driver {

     public static void main(String[] args) {

         A a = new B();
         a.staticMethod();

         A.staticMethod();

         B.staticMethod();

     }

 }

 Driver sınıfındaki B.staticMethod() çağrısına dikkat ediniz.
 Bu isimde static metot B sınıfında olmasa dahi çağrımın yapılabildiğine
 ve A sınıfındaki metodun çalıştırıldığına dikkat ediniz.
 Bu durumda B sınıfında aynı isimde static bir metot tanımlanacaksa
 erişim belirleyicisi daha kısıtlayıcı olmaması şartıyla tanımlanabilir.
 A.staticMethod(); satırına dikkat ediniz. Bu satır polymorfik bir çağrım
 mekanizması işletmez. Yani çalışma zamanında A sınıfını türeten sınıfları
 dikkate almaz.Eğer böyle bir şey söz konusu olsaydı A'yı türeten olası tüm
 sınıfların taranıp içlerinde staticMethod isimli static metot araması gerçekleştirilirdi.
 Bu durumun çalışma zamanına maliyetini düşünün.

 ------------------------------------------------------------------------

  Static Binding: Hangi metodun çalıştırılacağına derleme zamanında karar verilir.
  Bu, private, static ve final metotlar için geçerlidir.Derleyici bu metotların değiştirilmeyeceğini
  veya override edilemeyeceğini bildiği için, metot çağrısını doğrudan kodun adresine bağlayabilir.
  Bu çok hızlıdır.

  Dynamic Binding: Hangi metodun çalıştırılacağına çalışma zamanında programın o anki durumuna göre
  karar verilir.Bu override edilebilen tüm instance metotları için geçerlidir.


  final anahtar sözcüğü sınıf bağlamında da yazılabilir. Bunun anlamı:
  sınıfın extend edilemeyeceğidir.

public final class A {
}

public class B extends A{ // COMPILE TIME ERROR.
}

Standart kütüphanede String sınıfını inceyiniz.
--------------------------------------------------------------------------------------------------------
 ## FINAL ###

 final, anahtar kelimesi, bir bildirimin(veri alanı, metot, sınıf) tanımını "tamamlanmış/nihai hali budur" ve
 "değiştirilemez" olarak işaretler. JLS, bu "değişmezliğin" her bağlamda ne anlama geldiğini kesi kurallarla
 tanımlar.

 1. Alanlar(Fields) Bağlamında
  Bir alan final olarak bildirildiğinde, bu alana yalnızca bir kez değer atanabilir. Bu, ya bildirim anında ya da
  sınfın bir ctor metodunun içinde atanmış olmasını gerektirir.

    JLS : Bir final değişkene yalnızca bir kez atama yapılabilir. Eğer bir final değişken, atama yapılmadan önce kesin
    olarak atanmamış bir durumda değilse, ona atama yapılması bir derleme zamanı hatasıdır.

   Bu, final bir alanın değerinin programın yaşam döngüsü boyunca sabit kalacağını garanti altına alır.Referans tipleri
   için bu, referansın kendisinin sabitlenmesi anlamına gelir; referansın gösterdiği nesnenin iç durumu değişebilir.

2.Metot Bağlamında
 Bir metot final olarak bildirildirildiğinde, o metot alt sınıflar tarafından geçersiz kılınamaz (override edilemez).
 Bu, polimorfizmi doğrudan etkileyen bir kısıtlamadır.

  JLS: Bir metot, alt sınıfların onu override etmesini veya gizlemesini(hiding) önlemek için final olarak
  bildirilebilir.final bir metodu override etmeye çalışmak bir derleme zamanı hatasıdır.

  Bu kural,bir metodun davranışının kalıtım hiyerarşisi boyunca "değiştirilemez" olmasını sağlar.Bu metot için
  polimorfik davranış (yani çalışma zamanında farklı bir implementasyonun çağrılması) imkansız hale gelir.
  Çağrı, her zaman üst sınıftaki implementasyona çözümlenir.

 * Statik metotlarda kullanımı aşağıda hiding mekanızması ile birlikte ele alınacaktır

3.Sınıflar Bağlamında
 Bir sınıf final olarak bildirilidiğinde, o sınıf genişletilemez (extend edilemez), yani kendisinden "yeni" alt sınıflar
 türetilemez.
  JLS :
     Eğer final bir sınıfın adı, başka bir sınıf bildiriminin extends ifadesinde (doğrudan bir üst sınıfı belirtirken)
     yer alıyorsa, bu bir derleme zamanı hatasıdır.

  Bu, kalıtım zincirini o noktada sonlandırır.Yukarıda da bahsettiğimiz String gibi sınıfların final olması, bu sınıfların
  değişmezlik ve güvenlik garantilerini alt sınıflar tarafından bozulmasını engeller.


 Java'da Gizleme (Hiding) Mekanizması
 Hiding, genellikle overriding ile karıştırılan ancak temelde farklı çalışan bir mekanizmadır. Hiding, alanlar (fields)
 ve statik metotlar için geçerlidir ve karar derleme zamanında verilir.

 1. Alanların Gizlenmesi (Field Hiding)
 Bir alt sınıf, üst sınıfında bulunan aynı isimde bir alan bildirdiğinde, alt sınıfın alanı üst sınıfın alanını "gizler"
   JLS: Bir sınıf, belirli bir isimle bir alan bildirdiğinde, bu bildirim, üst sınıflarındaki erişilebilir ve aynı
   isme sahip olan tüm alan bildirimlerini gizlemiş olur.

 Bu, alt sınıfın referansı üzerinden bu alana erişildiğinde alt sınıftaki değerin, üst sınıfın referansı üzerinden
 erişildiğinde ise üst sınıftaki değerin okunacağı anlamına gelir. Üst sınıftaki alan yok olmaz, sadece alt sınıfın
 görüş alanından gizlenir.

public class A {
    public int a = 100;
    public int b = 900;


}

public class B extends A{
    public int a = 90;
    public int b = 40;

}

public class Driver {

    public static void main(String[] args) {

        B b = new B();

        System.out.println(b.a); // 90

        A a = b;

        System.out.println(a.a); // 100
    }
}

Yukarıdaki örnek bize şunu göstermiştir: Erişilen alan referansın derleme zamanındaki türüne bağlıdır, nesnenin
çalışma zamanındaki türüne değil.

2. Static Metotların Gizlenmesi
Bu, hiding'in en önemli ve overriding ile en çok karıştırılan kısmıdır. Bir alt sınıf bir static metot ile aynı imzaya
sahip yeni bir statik metot bildirdiğinde, bu metot üst sınıftaki metodu gizler.

JLS :
 1. Bir C sınıfı bir statik m metodu bildirirse,
 2. Ve bu m metodu, C'nin bir A üst sınıfındaki bir statik m metodu ile aynı imzaya sahipse
 3. O zaman C sınıfındaki m metodunun, A sınıfındaki m metodunu gizlediği söylenir.

 En kritik fark: Overriding'de hangi metodun çağrılacağına çalışma zamanında nesnenin tipine göre karar verilir.
 Hiding'se ise hangi metodun çağrılacağına derleme zamanında referansın tipine göre karar verilir.

** static ve final Metotlar
  Bu iki modifier'ı birleştirip bir metot bildiriminde kullandığımızda bir soru ortaya çıkar:
  Zaten override edilemeyen static bir metoda, "override edilemez" anlamına gelen final eklemek neden gereklidir ?

 Cevap, final anahtar sözcüğünün JLS'teki tanımının hiding ile ilgili vurgusunda gizlidir.

 JLS 4.3 (final methods)
    "A method can be declared final to prevent subclasses from overring OR HIDING it. It is a compile-time error to
    attempt to override a final method"
     "Bir metot, alt snıfların onu override etmesini veya GİZLEMESİNİ önlemek için final olarak bildirilebilir.final
     bir metodu override etmeye çalışmak derleme zamanı hatasıdır."

     İşte kritik nokta budur: final anahtar kelimesi sadece override işlemini değil, aynı zamanda hiding işlemini de engeller.

 Anlamı ve Sonuçları
  static bir metodun final olarak tanımlanabilmesi şu anlamlara gelir:
   1. Gereksizlik (Redundancy): final anahtar kelimesinin override etmeyi engelleyici özelliği, static bir metot için
      gereksizdir, çünkü static metotlar zaten override edilemezler.

   2. Asıl Amaç: final anahtar kelimesinin asıl gücü burada ortaya çıkar.static bir metoda final eklediğinizde, o metodun
   alt sınıflar tarafından gizlenmesini engellemiş olursunuz.
   Bu bir üst sınıf tasarımcısı olarak şu kesin ve net mesajı verdiğiniz anlamına gelir :
   "Bu sınıfa ait bu yardımcı metodun davranışı sabittir ve bu kalıtım hiyerarşisindeki hiçbir alt sınıf,i bu isimde başka
   bir static metot tanımlayarak bu davranışı gizleyemez veya değiştiremez."













